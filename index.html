<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mikemajzoub.com</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background-color: #fafafa;
            color: #333333;
            min-height: 100vh;
            margin: 0;
            position: relative;
        }

        /* The canvas element for the animation */
        #neural-network-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

        .terminal-card {
            background-color: rgba(255, 255, 255, 1); /* Semi-transparent background to show animation */
            border: 1px solid #c0c0c0;
            z-index: 10;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .code-link {
            transition: all 0.3s ease;
            text-decoration: none;
        }

        .code-link:hover {
            color: #555555;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body>

    <canvas id="neural-network-canvas"></canvas>
    <div class="terminal-card p-4 rounded-xl w-fit flex">
        <pre class="text-lg text-[#555555] m-0 text-left">
// mikemajzoub.com
// <a href="https://www.linkedin.com/in/mikemajzoub/" target="_blank" class="text-blue-600 hover:underline">linkedin</a>, <a href="https://x.com/mikemajzoub" target="_blank" class="text-blue-600 hover:underline">x</a></pre>
    </div>

    <script>
        window.onload = function() {
            const canvas = document.getElementById('neural-network-canvas');
            const ctx = canvas.getContext('2d');

            let width, height;
            let layers = [];
            const layerNodeCounts = [16, 16, 16, 16, 1];
            const nodeRadius = 2;
            const outputWords = [
                "ğŸ˜€", "ğŸ˜ƒ", "ğŸ˜„", "ğŸ˜", "ğŸ˜†",
                "ğŸ˜…", "ğŸ˜‚", "ğŸ¤£", "ğŸ˜Š", "ğŸ˜‡",
                "ğŸ˜‰", "ğŸ˜‹", "ğŸ˜Œ", "ğŸ¤—", "ğŸ¥°",
                "ğŸ¤©", "ğŸ¥³", "ğŸ˜", "ğŸ¤ª", "ğŸ¥³"
            ];
            let outputNode;
            let currentWordIndex = -1; // Initialize to -1 to hide the word initially

            let currentActiveLayerIndex = 0;
            let connectionAnimations = [];
            let pauseUntil = 0;
            const PAUSE_DURATION = 750; // milliseconds
            let hasAnimationCompleted = false;
            
            function resizeCanvas() {
                width = canvas.width = window.innerWidth;
                height = canvas.height = window.innerHeight;
                initNodes();
            }

            class Node {
                constructor(x, y) {
                    this.x = x;
                    this.y = y;
                    this.thickness = 0.2 + Math.random() * 0.8; // Adjusted random thickness for a very thin look
                }

                draw() {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, nodeRadius, 0, Math.PI * 2);
                    ctx.fillStyle = '#333333';
                    ctx.fill();
                }
            }
            
            class TextNode {
                constructor(x, y) {
                    this.x = x;
                    this.y = y;
                    this.animationStartTime = 0;
                }

                startFade() {
                    this.animationStartTime = performance.now();
                }

                draw(text) {
                    if (currentWordIndex !== -1) {
                        const elapsedTime = performance.now() - this.animationStartTime;
                        let opacity;
                        if (elapsedTime < 1000) {
                            opacity = 1.0;
                        } else {
                            const fadeElapsedTime = elapsedTime - 1000;
                            opacity = 1.0 - Math.min(1.0, fadeElapsedTime / 1000); // Fades from 1.0 to 0.0 over 1 second
                        }
                        
                        ctx.font = '16px "Courier New", monospace';
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'middle';
                        ctx.fillStyle = `rgba(51, 51, 51, ${opacity})`;
                        // Add a 1rem (16px) offset to the x-coordinate
                        ctx.fillText(text, this.x + 16, this.y);
                        
                    }
                }
            }

            function initNodes() {
                layers = [];
                connectionAnimations = [];
                const paddingX = 0.1 * width; // Responsive padding based on width
                const wordWidth = 150; 
                const totalWidthForLayers = width - 2 * paddingX - wordWidth;
                const layerSpacing = totalWidthForLayers / (layerNodeCounts.length - 1);
                
                // Create nodes for all layers except the last (output) one
                for (let i = 0; i < layerNodeCounts.length - 1; i++) {
                    const layer = [];
                    const nodeCount = layerNodeCounts[i];
                    const nodeSpacing = (height - 100) / (nodeCount + 1);
                    const x = paddingX + i * layerSpacing;

                    for (let j = 0; j < nodeCount; j++) {
                        const y = 50 + j * nodeSpacing;
                        layer.push(new Node(x, y));
                    }
                    layers.push(layer);
                }

                // Create the single output node and place it to the right of the last layer
                const finalX = paddingX + (layerNodeCounts.length - 2) * layerSpacing;
                outputNode = new TextNode(finalX + 150, height / 2);


                // Create connections between layers
                for (let i = 0; i < layers.length - 1; i++) {
                    const connections = [];
                    const currentLayer = layers[i];
                    const nextLayer = layers[i + 1];

                    currentLayer.forEach(nodeA => {
                        nextLayer.forEach(nodeB => {
                            connections.push({ from: nodeA, to: nodeB, progress: 0, speed: 0.02 + Math.random() * 0.008 });
                        });
                    });
                    connectionAnimations.push(connections);
                }

                // Create connections for the last layer to the single output node
                const lastLayerConnections = [];
                const lastHiddenLayer = layers[layers.length - 1];
                lastHiddenLayer.forEach(node => {
                    lastLayerConnections.push({ from: node, to: outputNode, progress: 0, speed: 0.02 + Math.random() * 0.008 });
                });
                connectionAnimations.push(lastLayerConnections);
            }
            
            function drawConnections() {
                // Draw animated layers (the active path)
                for (let i = 0; i < connectionAnimations.length; i++) {
                    const layerConnections = connectionAnimations[i];
                    
                    let opacity = 0;
                    if (i < currentActiveLayerIndex) {
                        opacity = 1;
                    } else if (i === currentActiveLayerIndex) {
                        opacity = layerConnections[0].progress;
                    }
                    
                    if (opacity > 0) {
                        layerConnections.forEach(conn => {
                            const dx = conn.to.x - conn.from.x;
                            const dy = conn.to.y - conn.from.y;
                            const endX = conn.from.x + dx * conn.progress;
                            const endY = conn.from.y + dy * conn.progress;
                            
                            // Map thickness to a hue value (240=blue to 0=red)
                            const hue = 240 - ((conn.from.thickness - 0.2) / 0.8) * 240;
                            
                            // Use the thickness of the starting node
                            ctx.lineWidth = conn.from.thickness;
                            ctx.strokeStyle = `hsla(${hue}, 100%, 50%, ${opacity})`;
                            ctx.beginPath();
                            ctx.moveTo(conn.from.x, conn.from.y);
                            ctx.lineTo(endX, endY);
                            ctx.stroke();
                        });
                    }
                }
            }
            
            function animate() {
                ctx.clearRect(0, 0, width, height);

                // Draw connections
                drawConnections();
                
                // Draw nodes and word (after connections)
                layers.forEach(layer => {
                    layer.forEach(node => {
                        if (node.draw) {
                           node.draw();
                        }
                    });
                });

                if (outputNode && currentWordIndex !== -1) {
                    outputNode.draw(outputWords[currentWordIndex]);
                }
                
                // --- Animation Logic ---
                // The animation logic remains the same
                
                // Check for pause state
                if (Date.now() < pauseUntil) {
                    requestAnimationFrame(animate);
                    return;
                }
                
                // If a pause just ended, reset the animation and change the word
                if (hasAnimationCompleted) {
                    hasAnimationCompleted = false;
                    currentActiveLayerIndex = 0;

                    // Reset and re-randomize thickness and speed for all nodes and connections
                    layers.forEach(layer => {
                        layer.forEach(node => {
                            node.thickness = 0.2 + Math.random() * 0.8;
                        });
                    });

                    connectionAnimations.forEach(layerConnections => {
                        layerConnections.forEach(conn => {
                            conn.progress = 0;
                            conn.speed = 0.02 + Math.random() * 0.008;
                        });
                    });
                }

                let isLayerComplete = true;
                if (currentActiveLayerIndex < connectionAnimations.length) {
                    connectionAnimations[currentActiveLayerIndex].forEach(conn => {
                        conn.progress = Math.min(1, conn.progress + conn.speed);
                        if (conn.progress < 1) {
                            isLayerComplete = false;
                        }
                    });
                } else {
                    isLayerComplete = true;
                }

                if (isLayerComplete) {
                    if (currentActiveLayerIndex >= connectionAnimations.length - 1) {
                         // Animation complete, set flags for pause
                         currentWordIndex = (currentWordIndex + 1) % outputWords.length;
                         outputNode.startFade();
                         pauseUntil = Date.now() + PAUSE_DURATION;
                         hasAnimationCompleted = true;
                    } else {
                         currentActiveLayerIndex++;
                    }
                }
                
                requestAnimationFrame(animate);
            }

            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            animate();
        };
    </script>

</body>
</html>
